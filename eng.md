60 FPS or Bust: Dynamically Prerendering CSS Animations
------------------------------------------------------------

Creating better animations for the web has been something I’ve been working on
for a few years, and I’ve just figured out a new method that offers more
flexibility and animation fidelity than was previously available. I call it “CSS
prerendering,” and it’s easier than you think.

## CSS vs. JavaScript animations ##

In the beginning, there was JavaScript. For years, JavaScript was the only way
to add animation to a web page. As web standards matured, CSS become more
featureful and offered transitions and animations. These browser-native CSS
features are capable of delivering much smoother animation than JavaScript,
because the browser seems to be able to optimize native animation. However, CSS
animations and transitions are not terribly flexible, leaving developers to
choose between a smooth, 60 frames per second animation, or an animation that
can adapt to the needs of an application on the fly.

CSS animations (`@keyframes`) are inflexible because they must be hard-coded.
Transitions are a little easier to work with, as they can gracefully respond to
any CSS changes performed by JavaScript. However, the complexity that CSS
transitions can give you is pretty limited — an animation with multiple steps is
difficult to achieve. This is a problem that CSS `@keyframe` animations are
meant to solve, but they don’t offer the level of dynamic responsiveness that
transitions do.

CSS `@keyframe` animations are also limited by the native easing formulae
available — there are only six. This is not enough to meet the needs of all
designs. Joe Lambert came up with a way around this with [Morf][1]; a tool that
generates a `@-webkit-keyframe` animation with many tiny steps. This opens the
door to an unlimited selection of easing formulae. I decided to build on top of
this idea with [Rekapi][2]’s [`toCSS` feature][3], which uses a straightforward
[keyframe API][4] to generate cross-browser compatible CSS code. I then used
that functionality to create [Stylie][5], which provides a UI to create
animations and exports it to CSS code.

While I feel that a robust UI to prototype and tweak CSS animations is
essential, the process of configuring an animation and then copy/pasting
potentially hundreds of lines of code into a static CSS file is inelegant and
highly inflexible. I felt that there had to be a better way. Enter CSS
prerendering.

## CSS prerendering ##

The idea behind CSS prerendering is pretty straightforward — you create a CSS
`@keyframe` string at runtime with JavaScript, inject it into a dynamically-
created `<style>` element, and then insert that element into the DOM. When the
animation is complete, you simply remove the `<style>` element from the DOM.
This approach works surprisingly well, particularly in WebKit-based browsers
(other rendering engines still need to catch up).

Until now, there haven’t been any tools that I could find that can do this, so I
decided to fill this void with Rekapi’s [`CSSRenderer` module][6]. Rekapi’s goal
is to provide a usable and flexible API for creating keyframe animations, and
historically it only performed JavaScript-based animations. With the
`CSSRenderer`, you can use the same API to create a CSS `@keyframe` animation,
making for magically smoother animations that don’t block the JavaScript thread.
But don’t take my word for it, [you can see the difference for yourself][7]. The
difference in quality is far more pronounced on mobile devices, especially iOS.


## Creating a CSS animation with Rekapi ##

To create a CSS `@keyframe` animation that works in every browser, you need
something like this (generated by Stylie):

  .stylie {
    -moz-animation-name: stylie-transform-keyframes;
    -moz-animation-duration: 2000ms;
    -moz-animation-delay: 0ms;
    -moz-animation-fill-mode: forwards;
    -moz-animation-iteration-count: infinite;
    -ms-animation-name: stylie-transform-keyframes;
    -ms-animation-duration: 2000ms;
    -ms-animation-delay: 0ms;
    -ms-animation-fill-mode: forwards;
    -ms-animation-iteration-count: infinite;
    -o-animation-name: stylie-transform-keyframes;
    -o-animation-duration: 2000ms;
    -o-animation-delay: 0ms;
    -o-animation-fill-mode: forwards;
    -o-animation-iteration-count: infinite;
    -webkit-animation-name: stylie-transform-keyframes;
    -webkit-animation-duration: 2000ms;
    -webkit-animation-delay: 0ms;
    -webkit-animation-fill-mode: forwards;
    -webkit-animation-iteration-count: infinite;
    animation-name: stylie-transform-keyframes;
    animation-duration: 2000ms;
    animation-delay: 0ms;
    animation-fill-mode: forwards;
    animation-iteration-count: infinite;
  }
  @-moz-keyframes stylie-transform-keyframes {
    0% {-moz-transform:translateX(0px) translateY(0px);}
    100% {-moz-transform:translateX(400px) translateY(0px);}
  }
  @-ms-keyframes stylie-transform-keyframes {
    0% {-ms-transform:translateX(0px) translateY(0px);}
    100% {-ms-transform:translateX(400px) translateY(0px);}
  }
  @-o-keyframes stylie-transform-keyframes {
    0% {-o-transform:translateX(0px) translateY(0px);}
    100% {-o-transform:translateX(400px) translateY(0px);}
  }
  @-webkit-keyframes stylie-transform-keyframes {
    0% {-webkit-transform:translateX(0px) translateY(0px);}
    100% {-webkit-transform:translateX(400px) translateY(0px);}
  }
  @keyframes stylie-transform-keyframes {
    0% {transform:translateX(0px) translateY(0px);}
    100% {transform:translateX(400px) translateY(0px);}
  }

…And then paste that into your CSS code. That’s just for one, very simple
…animation. Here’s how that same animation might be set up with Rekapi’s
…`CSSRenderer`:

	var kapi = new Kapi();
	var actor = new Kapi.DOMActor(
	    document.getElementsByClass('stylie')[0]);

	kapi.addActor(actor);
	actor
	  .keyframe(0, {
	      transform: 'translateX(0px) translateY(0px)'});
	  .keyframe(2000, {
	      transform: 'translateX(400px) translateY(0px)'});

	// Feature detect for @keyframe support
	 if (kapi.css.canAnimateWithCSS()) {
	   kapi.css.play();
	 } else {
	   kapi.play();
	 }

Rekapi handles all of the vendor prefixing for you, so you only need to write an
animation once. And if the browser doesn’t support CSS animations, Rekapi will
gracefully fall back to an old-fashioned JavaScript animation, which it has
always supported. To see what kinds of complex animations Rekapi can handle, I
encourage you to check out [Stylie][5], which is simply a graphical front end
for Rekapi.


## Better animations ##

CSS lets developers and designers create fluid, efficient animations that don’t
block the JavaScript thread. However, we have lacked the tools to make them easy
to work with. I really want to solve this problem, and I think that [Rekapi][2]
and [it’s `CSSRenderer`][6] significantly narrow the gap between performance and
flexibility. I hope that CSS prerendering becomes more widely used, as it
enables a much smoother web experience. [I’d love to know][8] how CSS
prerendering works for you, and if you find any bugs, [please report them][9].
Happy animating!


[1]: http://www.joelambert.co.uk/morf/
[2]: http://rekapi.com/
[3]: http://rekapi.com/dist/doc/ext/to-css/rekapi.to-css.js.html
[4]: http://rekapi.com/dist/doc/src/rekapi.actor.js.html#keyframe
[5]: http://jeremyckahn.github.io/stylie/
[6]: http://rekapi.com/dist/doc/ext/css-animate/rekapi.css-animate.context.js.html
[7]: http://rekapi.com/ext/css-animate/sample/play-many-actors.html
[8]: https://twitter.com/jeremyckahn
[9]: https://github.com/jeremyckahn/rekapi/issues?page=1&state=open